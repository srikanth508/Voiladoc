import { Injector } from "@angular/core";
import { Observable } from "rxjs";
export declare class Translator {
    private _module;
    private injector;
    private static regExpFromPattern;
    private _language;
    private config;
    private logHandler;
    private loader;
    private languageChangedObservable;
    private languageChangedObserver;
    private loadedLanguages;
    private translations;
    constructor(_module: string, injector: Injector);
    readonly languageChanged: Observable<string>;
    readonly module: string;
    language: string;
    /**
     * Waits for the current language to be loaded.
     *
     * @param {string?} language
     * @returns {Promise<void>|Promise}
     */
    waitForTranslation(language?: string): Promise<void>;
    /**
     * Translate keys for current language or given language asynchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * Using an array of keys is deprecated and will be removed in future. Please use translateArray instead.
     *
     * @param {string|string[]} keys
     * @param {any?} params
     * @param {string?} language
     * @returns {Promise<string|string[]>|Promise}
     */
    translate(keys: string | string[], params?: any, language?: string): Promise<string | string[]>;
    /**
     * Translate keys for current language or given language asynchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string[]} keys
     * @param {any?} params
     * @param {string?} language
     * @returns {Promise<string[]>|Promise}
     */
    translateArray(keys: string[], params?: any, language?: string): Promise<string[]>;
    /**
     * Search pattern for current language or given language asynchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string} pattern
     * @param {any?} params
     * @param {string?} language
     * @returns {Promise<object>|Promise}
     */
    translateSearch(pattern: string, params?: any, language?: string): Promise<object>;
    /**
     * Translate keys for current language and return an observable.
     *
     * The observable gets new translations if the language get changed.
     *
     * Using an array of keys is deprecated and will be removed in future. Please use observeArray instead.
     *
     * @param {string|string[]} keys
     * @param {any?} params
     * @returns {Observable<string|string[]>}
     */
    observe(keys: string | string[], params?: any): Observable<string | string[]>;
    /**
     * Translate keys for current language and return an observable.
     *
     * The observable gets new translations if the language get changed.
     *
     * @param {string[]} keys
     * @param {any?} params
     * @returns {Observable<string[]>}
     */
    observeArray(keys: string[], params?: any): Observable<string[]>;
    /**
     * Search pattern for current language and return an observable.
     *
     * The observable gets new translations if the language get changed.
     *
     * @param {string} pattern
     * @param {any?} params
     * @returns {Observable<Object>}
     */
    observeSearch(pattern: string, params?: any): Observable<object>;
    /**
     * Translate keys for current language or given language synchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * Using an array of keys is deprecated and will be removed in future. Please use instantArray instead.
     *
     * @param {string|string[]} key
     * @param {any?} params
     * @param {string?} language
     * @returns {string|string[]}
     */
    instant(key: string | string[], params?: any, language?: string): string | string[];
    /**
     * Translate keys for current language or given language synchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string[]} keys
     * @param {any?} params
     * @param {string?} language
     * @returns {string[]}
     */
    instantArray(keys: string[], params?: any, language?: string): string[];
    /**
     * Search pattern for current language or given language synchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string} pattern
     * @param {any?} params
     * @param {string?} language
     * @returns {Object}
     */
    search(pattern: string, params?: any, language?: string): object;
    /**
     * Get the current language or the provided language.
     *
     * @param {string} language
     * @returns {string}
     */
    private getSelectedLanguage;
    /**
     * Load a language.
     *
     * @param {string} language
     * @returns {Promise<void>|Promise}
     * @private
     */
    private loadLanguage;
    private interpolate;
    /**
     * Parses the expression in the given __context.
     *
     * @param   {string} expression
     * @param   {object} __context
     * @returns {any}
     * @private
     */
    private parse;
    /**
     * Transforms value with pipeExpression in given __context.
     *
     * @param {any} value
     * @param {string} pipeExpression
     * @param {any} __context
     * @returns {any}
     */
    private pipeTransform;
    /**
     * Get a pipe from injector
     *
     * @param pipeName
     * @returns {PipeTransform}
     */
    private getPipe;
    /**
     * Outputs a parse error for an error in translation references.
     *
     * @param   {string} sub
     * @param   {string} unexpected
     * @param   {string} expected
     * @param   {number} pos
     * @returns {string}
     * @private
     */
    private referencedError;
    /**
     * Gets a parameter from params defined by getter recursive.
     *
     * @param   {object} params
     * @param   {string} getter
     * @returns {any}
     * @private
     */
    private getParam;
    /**
     * Translates a reference expression like '<key> [: <param> [= <getter> [, <param..n> [= <getter..n>]]]]'
     *
     * @param   {string} sub
     * @param   {string} expression
     * @param   {Object} params
     * @param   {string} lang
     * @returns {string}
     * @private
     */
    private translateReferenced;
    private generateMessage;
}
