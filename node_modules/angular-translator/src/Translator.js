import { TranslateLogHandler } from "./TranslateLogHandler";
import { TranslatorConfig } from "./TranslatorConfig";
import { TranslatorContainer } from "./TranslatorContainer";
import { Observable } from "rxjs";
import { share } from "rxjs/operators";
var Translator = /** @class */ (function () {
    function Translator(_module, injector) {
        var _this = this;
        this._module = _module;
        this.injector = injector;
        this._language = "en";
        this.loadedLanguages = {};
        this.translations = {};
        var translatorConfig = injector.get(TranslatorConfig);
        this.logHandler = injector.get(TranslateLogHandler);
        var translatorContainer = injector.get(TranslatorContainer);
        this.config = _module === "default" ? translatorConfig : translatorConfig.module(_module);
        var providedLanguage = this.config.providedLanguage(translatorContainer.language);
        if (typeof providedLanguage === "string") {
            this._language = providedLanguage;
        }
        else {
            this._language = this.config.defaultLanguage;
        }
        this.languageChangedObservable = new Observable(function (observer) {
            _this.languageChangedObserver = observer;
        }).pipe(share());
        translatorContainer.languageChanged.subscribe(function (language) {
            _this.language = language;
        });
    }
    Translator.regExpFromPattern = function (pattern) {
        return new RegExp("^" +
            pattern.split(".").join("\\.")
                .replace(/[^a-z0-9.\\*?]/gi, ".")
                .split("*").join("(.*)")
                .split("?").join("(.)") +
            "$");
    };
    Object.defineProperty(Translator.prototype, "languageChanged", {
        get: function () {
            return this.languageChangedObservable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Translator.prototype, "module", {
        get: function () {
            return this._module;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Translator.prototype, "language", {
        get: function () {
            return this._language;
        },
        set: function (language) {
            var providedLanguage = this.config.providedLanguage(language, true);
            if (typeof providedLanguage === "string") {
                this._language = providedLanguage;
                this.logHandler.info(this.generateMessage("language changed", { language: providedLanguage }));
                // only when someone subscribes the observer get created
                if (this.languageChangedObserver) {
                    this.languageChangedObserver.next(providedLanguage);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Waits for the current language to be loaded.
     *
     * @param {string?} language
     * @returns {Promise<void>|Promise}
     */
    Translator.prototype.waitForTranslation = function (language) {
        language = this.getSelectedLanguage(language);
        if (!language) {
            return Promise.reject("Language " + arguments[0] + " not provided");
        }
        return this.loadLanguage(language);
    };
    /**
     * Translate keys for current language or given language asynchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * Using an array of keys is deprecated and will be removed in future. Please use translateArray instead.
     *
     * @param {string|string[]} keys
     * @param {any?} params
     * @param {string?} language
     * @returns {Promise<string|string[]>|Promise}
     */
    Translator.prototype.translate = function (keys, params, language) {
        var _this = this;
        if (params === void 0) { params = {}; }
        language = this.getSelectedLanguage(language);
        if (!language) {
            return Promise.resolve(keys);
        }
        if (Array.isArray(keys)) {
            return this.translateArray(keys, params, language);
        }
        return new Promise(function (resolve) {
            _this.loadLanguage(language).then(function () {
                resolve(_this.instant(keys, params, language));
            }, function () {
                resolve(keys);
            });
        });
    };
    /**
     * Translate keys for current language or given language asynchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string[]} keys
     * @param {any?} params
     * @param {string?} language
     * @returns {Promise<string[]>|Promise}
     */
    Translator.prototype.translateArray = function (keys, params, language) {
        var _this = this;
        if (params === void 0) { params = {}; }
        language = this.getSelectedLanguage(language);
        if (!language) {
            return Promise.resolve(keys);
        }
        return new Promise(function (resolve) {
            _this.loadLanguage(language).then(function () {
                resolve(_this.instantArray(keys, params, language));
            }, function () {
                resolve(keys);
            });
        });
    };
    /**
     * Search pattern for current language or given language asynchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string} pattern
     * @param {any?} params
     * @param {string?} language
     * @returns {Promise<object>|Promise}
     */
    Translator.prototype.translateSearch = function (pattern, params, language) {
        var _this = this;
        if (params === void 0) { params = {}; }
        language = this.getSelectedLanguage(language);
        if (!language) {
            return Promise.resolve({});
        }
        return new Promise(function (resolve) {
            _this.loadLanguage(language).then(function () {
                resolve(_this.search(pattern, params, language));
            }, function () {
                resolve({});
            });
        });
    };
    /**
     * Translate keys for current language and return an observable.
     *
     * The observable gets new translations if the language get changed.
     *
     * Using an array of keys is deprecated and will be removed in future. Please use observeArray instead.
     *
     * @param {string|string[]} keys
     * @param {any?} params
     * @returns {Observable<string|string[]>}
     */
    Translator.prototype.observe = function (keys, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (Array.isArray(keys)) {
            return this.observeArray(keys, params);
        }
        return new Observable(function (observer) {
            var next = function (translations) {
                observer.next(translations);
            };
            _this.translate(keys, params).then(next);
            _this.languageChangedObservable.subscribe(function () {
                _this.translate(keys, params).then(next);
            });
        });
    };
    /**
     * Translate keys for current language and return an observable.
     *
     * The observable gets new translations if the language get changed.
     *
     * @param {string[]} keys
     * @param {any?} params
     * @returns {Observable<string[]>}
     */
    Translator.prototype.observeArray = function (keys, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        return new Observable(function (observer) {
            var next = function (translations) {
                observer.next(translations);
            };
            _this.translateArray(keys, params).then(next);
            _this.languageChangedObservable.subscribe(function () {
                _this.translateArray(keys, params).then(next);
            });
        });
    };
    /**
     * Search pattern for current language and return an observable.
     *
     * The observable gets new translations if the language get changed.
     *
     * @param {string} pattern
     * @param {any?} params
     * @returns {Observable<Object>}
     */
    Translator.prototype.observeSearch = function (pattern, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        return new Observable(function (observer) {
            var next = function (translations) {
                observer.next(translations);
            };
            _this.translateSearch(pattern, params).then(next);
            _this.languageChangedObservable.subscribe(function () {
                _this.translateSearch(pattern, params).then(next);
            });
        });
    };
    /**
     * Translate keys for current language or given language synchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * Using an array of keys is deprecated and will be removed in future. Please use instantArray instead.
     *
     * @param {string|string[]} key
     * @param {any?} params
     * @param {string?} language
     * @returns {string|string[]}
     */
    Translator.prototype.instant = function (key, params, language) {
        var _this = this;
        if (params === void 0) { params = {}; }
        // backward compatibility
        if (Array.isArray(key)) {
            return this.instantArray(key, params, language);
        }
        language = this.getSelectedLanguage(language);
        if (!language) {
            return key;
        }
        var t;
        if (!this.translations[language] || !this.translations[language][key]) {
            this.logHandler.info(this.generateMessage("missing", { key: key, language: language }));
            if (language === this.config.defaultLanguage) {
                // this key is not available in the default language, returns key
                return key;
            }
            else {
                // use default language to translate the key
                t = this.instant(key, params, this.config.defaultLanguage);
            }
        }
        else {
            t = this.translations[language][key];
        }
        // resolve references to other translations
        t = t.replace(/\[\[([\sA-Za-z0-9_.,=:-]*)]]/g, function (sub, expression) {
            return _this.translateReferenced(sub, expression, params, language);
        });
        // simple interpolation
        t = t.replace(/{{\s*(.*?)\s*}}/g, function (sub, expression) {
            try {
                return String(_this.interpolate(expression, params)) || "";
            }
            catch (e) {
                if (e && e.message && e.message.indexOf("is not defined") === -1) {
                    _this.logHandler.error("Parse error for expression '" + sub + "'");
                    _this.logHandler.error(e);
                }
                return "";
            }
        });
        return t;
    };
    /**
     * Translate keys for current language or given language synchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string[]} keys
     * @param {any?} params
     * @param {string?} language
     * @returns {string[]}
     */
    Translator.prototype.instantArray = function (keys, params, language) {
        var _this = this;
        if (params === void 0) { params = {}; }
        language = this.getSelectedLanguage(language);
        if (!language) {
            return keys;
        }
        return keys.map(function (key) { return _this.instant(key, params, language); });
    };
    /**
     * Search pattern for current language or given language synchronously.
     *
     * Optionally you can pass params for translation to be interpolated.
     *
     * @param {string} pattern
     * @param {any?} params
     * @param {string?} language
     * @returns {Object}
     */
    Translator.prototype.search = function (pattern, params, language) {
        if (params === void 0) { params = {}; }
        var result = {};
        language = this.getSelectedLanguage(language);
        if (!language || !this.translations[language]) {
            return result;
        }
        var regExp = Translator.regExpFromPattern(pattern);
        var keys = Object.keys(this.translations[language]).filter(function (key) {
            return key.match(regExp) !== null;
        });
        if (keys.length === 0) {
            return result;
        }
        var i = keys.length;
        var translations = this.instant(keys, params, language);
        while (i--) {
            var k = keys[i].replace(regExp, function (substring) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                args.pop(); // pop out the search string
                args.pop(); // pop out the offset
                return args.length > 0 ? args.join("") : substring;
            });
            result[k] = translations[i];
        }
        return result;
    };
    /**
     * Get the current language or the provided language.
     *
     * @param {string} language
     * @returns {string}
     */
    Translator.prototype.getSelectedLanguage = function (language) {
        if (language) {
            var providedLanguage = this.config.providedLanguage(language, true);
            if (providedLanguage) {
                return String(providedLanguage);
            }
            else {
                this.logHandler.error(this.generateMessage("language not provided", { language: language }));
                return null;
            }
        }
        else {
            return this._language;
        }
    };
    /**
     * Load a language.
     *
     * @param {string} language
     * @returns {Promise<void>|Promise}
     * @private
     */
    Translator.prototype.loadLanguage = function (language) {
        var _this = this;
        if (!this.loader) {
            this.loader = this.injector.get(this.config.loader);
        }
        if (!this.loadedLanguages[language]) {
            this.loadedLanguages[language] = new Promise(function (resolve, reject) {
                var loaderOptions = _this.config.loaderOptions;
                loaderOptions.module = _this.module;
                loaderOptions.language = language;
                _this.loader.load(loaderOptions).then(function (translations) {
                    _this.translations[language] = translations;
                    _this.logHandler.info(_this.generateMessage("language loaded", { language: language }));
                    resolve();
                }, function (reason) {
                    _this.logHandler.error(_this.generateMessage("language not loaded", { language: language, reason: reason }));
                    reject(reason);
                });
            });
        }
        return this.loadedLanguages[language];
    };
    Translator.prototype.interpolate = function (expression, __context) {
        var expressions = expression.split("|");
        var result = this.parse(expressions.shift(), __context);
        while (expressions.length) {
            result = this.pipeTransform(result, expressions.shift().trim(), __context);
        }
        return result;
    };
    /**
     * Parses the expression in the given __context.
     *
     * @param   {string} expression
     * @param   {object} __context
     * @returns {any}
     * @private
     */
    Translator.prototype.parse = function (expression, __context) {
        var func = [];
        var varName;
        func.push("(function() {");
        if (Array.isArray(__context)) {
            this.logHandler.error("Parameters can not be an array.");
        }
        else {
            for (varName in __context) {
                if (!__context.hasOwnProperty(varName)) {
                    continue;
                }
                if (varName === "__context" || !varName.match(/[a-zA-Z_][a-zA-Z0-9_]*/)) {
                    this.logHandler.error("Parameter '" + varName + "' is not allowed.");
                    continue;
                }
                func.push("try { var " + varName + " = __context['" + varName + "']; } catch(e) {}");
            }
        }
        func.push("return (" + expression + "); })()");
        return eval(func.join("\n"));
    };
    /**
     * Transforms value with pipeExpression in given __context.
     *
     * @param {any} value
     * @param {string} pipeExpression
     * @param {any} __context
     * @returns {any}
     */
    Translator.prototype.pipeTransform = function (value, pipeExpression, __context) {
        var _a;
        var argExpressions = pipeExpression.split(":");
        var pipeName = argExpressions.shift();
        var args = [];
        var argExpression = "";
        while (argExpressions.length) {
            argExpression += argExpressions.shift();
            try {
                var arg = this.parse(argExpression, __context);
                argExpression = "";
                args.push(arg);
            }
            catch (e) {
                if (argExpressions.length === 0) {
                    this.logHandler.error(e);
                }
                argExpression += ":";
            }
        }
        return (_a = this.getPipe(pipeName)).transform.apply(_a, [value].concat(args));
    };
    /**
     * Get a pipe from injector
     *
     * @param pipeName
     * @returns {PipeTransform}
     */
    Translator.prototype.getPipe = function (pipeName) {
        if (!this.config.pipes[pipeName]) {
            throw new Error("Pipe " + pipeName + " unknown");
        }
        return this.injector.get(this.config.pipes[pipeName]);
    };
    /**
     * Outputs a parse error for an error in translation references.
     *
     * @param   {string} sub
     * @param   {string} unexpected
     * @param   {string} expected
     * @param   {number} pos
     * @returns {string}
     * @private
     */
    Translator.prototype.referencedError = function (sub, unexpected, expected, pos) {
        var msg = "Parse error unexpected " + unexpected;
        if (pos !== undefined) {
            msg += " at pos " + (pos + 3);
        }
        msg += " expected " + expected;
        this.logHandler.error(msg + " in '" + sub + "'");
        return "";
    };
    /**
     * Gets a parameter from params defined by getter recursive.
     *
     * @param   {object} params
     * @param   {string} getter
     * @returns {any}
     * @private
     */
    Translator.prototype.getParam = function (params, getter) {
        var pos = getter.indexOf(".");
        if (pos === -1) {
            return params.hasOwnProperty(getter) ? params[getter] : undefined;
        }
        else {
            var key = getter.substr(0, pos);
            return params.hasOwnProperty(key) && typeof params[key] === "object" ?
                this.getParam(params[key], getter.substr(pos + 1)) : undefined;
        }
    };
    /**
     * Translates a reference expression like '<key> [: <param> [= <getter> [, <param..n> [= <getter..n>]]]]'
     *
     * @param   {string} sub
     * @param   {string} expression
     * @param   {Object} params
     * @param   {string} lang
     * @returns {string}
     * @private
     */
    Translator.prototype.translateReferenced = function (sub, expression, params, lang) {
        var _this = this;
        var j;
        var status = "wait_key";
        var key;
        var translateParams = {};
        var paramKey;
        var getter;
        var transferParam = function (useGetter) {
            if (useGetter === void 0) { useGetter = true; }
            if (useGetter && !paramKey) {
                if (typeof _this.getParam(params, getter) !== "object") {
                    _this.logHandler.error("Only objects can be passed as params in '" + sub + "'");
                }
                else {
                    translateParams = _this.getParam(params, getter);
                }
            }
            else {
                if (!useGetter) {
                    translateParams[paramKey] = _this.getParam(params, paramKey);
                }
                else {
                    translateParams[paramKey] = _this.getParam(params, getter);
                }
            }
        };
        for (j = 0; j < expression.length; j++) {
            switch (status) {
                case "wait_key":
                    if (expression[j].match(/\s/)) {
                        // nothing to do here
                    }
                    else if (expression[j].match(/[A-Za-z0-9_.-]/)) {
                        status = "read_key";
                        key = expression[j];
                    }
                    else {
                        return this.referencedError(sub, "character", "key", j);
                    }
                    break;
                case "read_key":
                    if (expression[j].match(/[A-Za-z0-9_.-]/)) {
                        key += expression[j];
                    }
                    else if (expression[j] === ":") {
                        status = "wait_param";
                    }
                    else if (expression[j].match(/\s/)) {
                        status = "key_readed";
                    }
                    else {
                        return this.referencedError(sub, "character", "colon or end", j);
                    }
                    break;
                case "key_readed":
                    if (expression[j].match(/\s/)) {
                        // nothing to do here
                    }
                    else if (expression[j] === ":") {
                        status = "wait_param";
                    }
                    else {
                        return this.referencedError(sub, "character", "colon or end", j);
                    }
                    break;
                case "wait_param":
                    if (expression[j].match(/\s/)) {
                        // nothing to do here
                    }
                    else if (expression[j].match(/[A-Za-z0-9_]/)) {
                        status = "read_param_key";
                        paramKey = expression[j];
                    }
                    else if (expression[j] === "=") {
                        if (Object.keys(translateParams).length > 0) {
                            this.logHandler.error("Parse error only first parameter can be passed as params in " + "'" + sub + "'");
                            return "";
                        }
                        status = "wait_getter";
                    }
                    else {
                        return this.referencedError(sub, "character", "parameter", j);
                    }
                    break;
                case "read_param_key":
                    if (expression[j].match(/[A-Za-z0-9_]/)) {
                        paramKey += expression[j];
                    }
                    else if (expression[j] === "=") {
                        status = "wait_getter";
                    }
                    else if (expression[j] === ",") {
                        transferParam(false);
                        status = "wait_param";
                    }
                    else if (expression[j].match(/\s/)) {
                        status = "param_key_readed";
                    }
                    else {
                        return this.referencedError(sub, "character", "comma, equal sign or end", j);
                    }
                    break;
                case "param_key_readed":
                    if (expression[j].match(/\s/)) {
                        // nothing to do here
                    }
                    else if (expression[j] === "=") {
                        status = "wait_getter";
                    }
                    else if (expression[j] === ",") {
                        transferParam(false);
                        status = "wait_param";
                    }
                    else {
                        return this.referencedError(sub, "character", "comma, equal sign or end", j);
                    }
                    break;
                case "wait_getter":
                    if (expression[j].match(/\s/)) {
                        // nothing to do here
                    }
                    else if (expression[j].match(/[A-Za-z0-9_]/)) {
                        status = "read_getter";
                        getter = expression[j];
                    }
                    else {
                        return this.referencedError(sub, "character", "getter", j);
                    }
                    break;
                case "read_getter":
                    if (expression[j].match(/[A-Za-z0-9_.]/)) {
                        getter += expression[j];
                    }
                    else if (expression[j].match(/\s/)) {
                        status = "getter_readed";
                    }
                    else if (expression[j] === ",") {
                        transferParam();
                        status = "wait_param";
                    }
                    else {
                        return this.referencedError(sub, "character", "comma or end", j);
                    }
                    break;
                case "getter_readed":
                    if (expression[j].match(/\s/)) {
                        // nothing to do here
                    }
                    else if (expression[j] === ",") {
                        transferParam();
                        status = "wait_param";
                    }
                    else {
                        return this.referencedError(sub, "character", "comma or end", j);
                    }
                    break;
            }
        }
        switch (status) {
            case "param_key_readed":
            case "read_param_key":
                transferParam(false);
                break;
            case "getter_readed":
            case "read_getter":
                transferParam();
                break;
            case "wait_key":
                return this.referencedError(sub, "end", "key");
            case "wait_param":
                return this.referencedError(sub, "end", "parameter");
            case "wait_getter":
                return this.referencedError(sub, "end", "getter");
        }
        return String(this.instant(key, translateParams, lang));
    };
    Translator.prototype.generateMessage = function (key, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        var msg;
        params.module = this.module;
        switch (key) {
            case "missing":
                msg = "Translation for '{{key}}'" +
                    " in{{ module !== 'default' ? \" module '\" + module + \"' and\" : '' }}" +
                    " language {{language}} not found";
                break;
            case "language changed":
                msg = "Language changed to {{language}}" +
                    "{{ module !== 'default' ? \" in module '\" + module + \"'\" : '' }}";
                break;
            case "language not provided":
                msg = "Language {{language}} not provided" +
                    "{{ module !== 'default' ? \" in module '\" + module + \"'\" : '' }}";
                break;
            case "language loaded":
                msg = "Language {{language}}" +
                    "{{ module !== 'default' ? \" for module '\" + module + \"'\" : '' }}" +
                    " got loaded";
                break;
            case "language not loaded":
                msg = "Language {{language}}" +
                    "{{ module !== 'default' ? \" for module '\" + module + \"'\" : '' }}" +
                    " could not be loaded ({{reason}})";
        }
        return msg.replace(/{{\s*(.*?)\s*}}/g, function (sub, expression) {
            return _this.parse(expression, params) || "";
        });
    };
    return Translator;
}());
export { Translator };
//# sourceMappingURL=Translator.js.map