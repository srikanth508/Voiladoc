import { TranslationLoaderJson } from "./TranslationLoader/Json";
import { CurrencyPipe, DatePipe, DecimalPipe, JsonPipe, LowerCasePipe, PercentPipe, SlicePipe, TitleCasePipe, UpperCasePipe, } from "@angular/common";
export var COMMON_PURE_PIPES = [
    CurrencyPipe,
    DatePipe,
    DecimalPipe,
    JsonPipe,
    LowerCasePipe,
    PercentPipe,
    SlicePipe,
    TitleCasePipe,
    UpperCasePipe,
];
export var COMMON_PURE_PIPES_MAP = {
    currency: CurrencyPipe,
    date: DatePipe,
    number: DecimalPipe,
    json: JsonPipe,
    lowercase: LowerCasePipe,
    percent: PercentPipe,
    slice: SlicePipe,
    titlecase: TitleCasePipe,
    uppercase: UpperCasePipe,
};
var TranslatorConfig = /** @class */ (function () {
    function TranslatorConfig(logHandler, options, module) {
        this.logHandler = logHandler;
        this.options = {
            defaultLanguage: "en",
            providedLanguages: ["en"],
            detectLanguage: true,
            preferExactMatches: false,
            navigatorLanguages: ["en"],
            loader: TranslationLoaderJson,
            pipes: Object.keys(COMMON_PURE_PIPES_MAP).map(function (key) { return COMMON_PURE_PIPES_MAP[key]; }),
            pipeMap: (function () {
                var pipes = {};
                for (var pipeName in COMMON_PURE_PIPES_MAP) {
                    if (COMMON_PURE_PIPES_MAP.hasOwnProperty(pipeName)) {
                        pipes[pipeName] = COMMON_PURE_PIPES_MAP[pipeName];
                    }
                }
                return pipes;
            })(),
        };
        this.options.navigatorLanguages = (function () {
            var navigator = TranslatorConfig.navigator;
            if (navigator.languages instanceof Array) {
                return Array.prototype.slice.call(navigator.languages);
            }
            else {
                return [
                    navigator.languages ||
                        navigator.language ||
                        navigator.browserLanguage ||
                        navigator.userLanguage,
                ].filter(function (v) {
                    return typeof v === "string";
                });
            }
        })();
        this.setOptions(options);
        this.moduleName = module;
    }
    /**
     * Normalize a language
     *
     * @param {string} languageString
     * @returns {string}
     */
    TranslatorConfig.normalizeLanguage = function (languageString) {
        if (!languageString.match(TranslatorConfig.isoRegEx)) {
            return languageString;
        }
        return languageString.replace(TranslatorConfig.isoRegEx, function (substring, language, country) {
            if (country === void 0) { country = ""; }
            language = language.toLowerCase();
            country = country.toUpperCase();
            return country ? language + "-" + country : language;
        });
    };
    Object.defineProperty(TranslatorConfig.prototype, "defaultLanguage", {
        get: function () {
            return this.options.defaultLanguage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslatorConfig.prototype, "providedLanguages", {
        get: function () {
            return this.options.providedLanguages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslatorConfig.prototype, "loader", {
        get: function () {
            return this.options.loader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslatorConfig.prototype, "loaderOptions", {
        get: function () {
            return this.options.loaderOptions || {};
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslatorConfig.prototype, "detectLanguage", {
        get: function () {
            return this.options.detectLanguage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslatorConfig.prototype, "preferExactMatches", {
        get: function () {
            return this.options.preferExactMatches;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslatorConfig.prototype, "navigatorLanguages", {
        get: function () {
            return this.options.navigatorLanguages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslatorConfig.prototype, "pipes", {
        get: function () {
            var _this = this;
            if (!this.pipeMap) {
                this.pipeMap = this.options.pipeMap;
                var mappedPipes_1 = Object.keys(this.pipeMap).map(function (key) { return _this.pipeMap[key]; });
                var unmappedPipes = this.options.pipes.filter(function (pipe) { return mappedPipes_1.indexOf(pipe) === -1; });
                while (unmappedPipes.length) {
                    var pipe = unmappedPipes.shift();
                    if (pipe.pipeName) {
                        this.pipeMap[pipe.pipeName] = pipe;
                    }
                    else {
                        this.logHandler.error("Pipe name for " + pipe.name + " can not be resolved");
                    }
                }
            }
            return this.pipeMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Overwrite the options.
     *
     * @param {any} options
     */
    TranslatorConfig.prototype.setOptions = function (options) {
        var _this = this;
        var _a;
        for (var key in options) {
            if (!options.hasOwnProperty(key)) {
                continue;
            }
            if (key === "pipes") {
                (_a = this.options.pipes).push.apply(_a, options.pipes.filter(function (pipe) {
                    return _this.options.pipes.indexOf(pipe) === -1;
                }));
            }
            else if (key === "pipeMap") {
                for (var pipeName in options.pipeMap) {
                    if (options.pipeMap.hasOwnProperty(pipeName)) {
                        this.options.pipeMap[pipeName] = options.pipeMap[pipeName];
                    }
                }
            }
            else {
                this.options[key] = options[key];
            }
        }
        if (this.options.providedLanguages.indexOf(this.options.defaultLanguage) === -1) {
            this.options.defaultLanguage = this.options.providedLanguages[0];
        }
    };
    /**
     * Checks if given language "language" is provided and returns the internal name.
     *
     * The checks running on normalized strings matching this pattern: /[a-z]{2}(-[A-Z]{2})?/
     * Transformation is done with this pattern: /^([A-Za-z]{2})([\.\-_\/]?([A-Za-z]{2}))?/
     *
     * If strict is false it checks country independent.
     *
     * @param {string} language
     * @param {boolean?} strict
     * @returns {string|boolean}
     */
    TranslatorConfig.prototype.providedLanguage = function (language, strict) {
        if (strict === void 0) { strict = false; }
        var providedLanguagesNormalized = this.providedLanguages.map(TranslatorConfig.normalizeLanguage);
        language = TranslatorConfig.normalizeLanguage(language);
        var p = providedLanguagesNormalized.indexOf(language);
        if (p > -1) {
            return this.providedLanguages[p];
        }
        else if (!strict && language.match(TranslatorConfig.isoRegEx)) {
            language = language.substr(0, 2);
            p = providedLanguagesNormalized.indexOf(language);
            if (p > -1) {
                return this.providedLanguages[p];
            }
            else {
                p = providedLanguagesNormalized
                    .map(function (l) {
                    return l.match(TranslatorConfig.isoRegEx) ? l.substr(0, 2) : l;
                })
                    .indexOf(language);
                if (p > -1) {
                    return this.providedLanguages[p];
                }
            }
        }
        return false;
    };
    /**
     * Get the configuration for module.
     *
     * @param {string} module
     * @returns {TranslatorConfig}
     */
    TranslatorConfig.prototype.module = function (module) {
        if (this.moduleName) {
            throw new Error("Module configs can not be stacked");
        }
        var moduleConfig = new TranslatorConfig(this.logHandler, this.options, module);
        if (this.options.modules && this.options.modules[module]) {
            moduleConfig.setOptions(this.options.modules[module]);
        }
        return moduleConfig;
    };
    TranslatorConfig.navigator = window && window.navigator ? window.navigator : {};
    TranslatorConfig.isoRegEx = /^([A-Za-z]{2})(?:[.\-_\/]?([A-Za-z]{2}))?$/;
    return TranslatorConfig;
}());
export { TranslatorConfig };
//# sourceMappingURL=TranslatorConfig.js.map